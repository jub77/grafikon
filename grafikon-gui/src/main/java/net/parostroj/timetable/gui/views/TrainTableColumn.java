package net.parostroj.timetable.gui.views;

import java.awt.Component;
import java.awt.Graphics;
import java.text.DecimalFormatSymbols;
import java.util.Enumeration;

import javax.swing.Icon;
import javax.swing.JLabel;
import javax.swing.JTable;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;

import net.parostroj.timetable.model.TimeInterval;
import net.parostroj.timetable.utils.ResourceLoader;

/**
 * Enumeration with columns for train view table.
 *
 * @author jub
 */
public enum TrainTableColumn {
    NODE("train.table.node", 50, 300, 120, "w", String.class, false, null),
    START("train.table.starttime", 50, 70, 50, "fc", String.class, true, null),
    END("train.table.endtime", 50, 70, 50, "loc", String.class, true, null),
    STOP("train.table.stop", 50, 50, 50, "flo", String.class, true, null),
    REAL_STOP("train.table.real.stop", 50, 50, 50, "w", Double.class, false, null),
    SPEED_LIMIT("train.table.speed.limit", 50, 50, 50, "e", Integer.class, false, null),
    SPEED("train.table.speed", 50, 50, 50, "w", Integer.class, false, null),
    ADDED_TIME("train.table.added.time", 50, 50, 50, "e", String.class, true, null),
    PLATFORM("train.table.platform", 50, 50, 50, "t", String.class, false, new TrackCellEditor()),
    WEIGHT("train.table.weight", 50, 100, 50, "w", Integer.class, false, null),
    LENGTH("train.table.length", 50, 100, 50, "w", Integer.class, false, null),
    CONFLICTS("train.table.conflicts", 50, 300, 75, "w", String.class, false, null),
    COMMENT_SHOWN("train.table.comment.shown", 30, 30, 30, "o", Boolean.class, false, null),
    COMMENT("train.table.comment", 1, Integer.MAX_VALUE, 150, "", String.class, false, null),
    OCCUPIED_ENTRY("train.table.occupied.track", 30, 30, 30, "fo", Boolean.class, false, null),
    SHUNT("train.table.shunt", 30, 30, 30, "fo", Boolean.class, false, null),
    SET_SPEED("train.table.set.speed", 50, 50, 50, "e", Integer.class, false, null),
    IGNORE_LENGTH("train.table.ignore.length", 30, 30, 30, "o", Boolean.class, false, null),
    MANAGED_FREIGHT("train.table.managed.freight", 30, 30, 30, "o", Boolean.class, false, null),
    REGION_CENTER_TRANSFER("train.table.region.center.transfer", 30, 30, 30, "fo", Boolean.class, false, null),
    FREIGHT_TO_STATIONS("train.table.freight.to.stations", 50, Integer.MAX_VALUE, 150, "w", String.class, false, null);

    private final String key;
    private final int minWidth;
    private final int prefWidth;
    private final int maxWidth;
    private final Class<?> clazz;
    private final boolean rightAling;
    private boolean even;
    private boolean odd;
    private boolean first;
    private boolean last;
    private boolean all;
    private boolean oneTrack;
    private final TableCellEditor editor;
    private boolean time;

    private static class TimeCellRenderer implements TableCellRenderer {

        private static final String END;
        private final TableCellRenderer wrapped;
        private final int width;
        private final Icon icon;

        static {
            END = String.valueOf(DecimalFormatSymbols.getInstance().getDecimalSeparator()) + '0';
        }

        public TimeCellRenderer(TableCellRenderer wrapped) {
            this.wrapped = wrapped;
            JLabel l = (JLabel) wrapped;
            this.width = SwingUtilities.computeStringWidth(l.getFontMetrics(l.getFont()), END);
            this.icon = new Icon() {
                @Override
                public void paintIcon(Component c, Graphics g, int x, int y) {
                    // nothing - empty space
                }

                @Override
                public int getIconWidth() {
                    return width;
                }

                @Override
                public int getIconHeight() {
                    return 1;
                }
            };
        }

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,
                boolean hasFocus, int row, int column) {
            String time = (String) value;
            Component component;
            if (time != null && time.endsWith(END)) {
                String text = time.substring(0, time.length() - 2);
                component = wrapped.getTableCellRendererComponent(table, text, isSelected, hasFocus, row, column);
                final JLabel l = (JLabel) component;
                l.setIcon(icon);
                l.setIconTextGap(0);
                l.setHorizontalTextPosition(SwingConstants.LEADING);
                l.setAlignmentX(SwingConstants.RIGHT);
            } else {
                component = wrapped.getTableCellRendererComponent(table, time, isSelected, hasFocus, row, column);
                JLabel l = (JLabel) component;
                l.setIcon(null);
                l.setIconTextGap(0);
                l.setHorizontalTextPosition(SwingConstants.LEADING);
                l.setAlignmentX(SwingConstants.RIGHT);
            }
            return component;
        }
    }

    TrainTableColumn(String key, int minWidth, int maxWidth, int prefWidth, String forbidden, Class<?> clazz,
            boolean rightAling, TableCellEditor editor) {
        this.key = key;
        this.minWidth = minWidth;
        this.maxWidth = maxWidth;
        this.prefWidth = prefWidth;
        this.clazz = clazz;
        this.rightAling = rightAling;
        this.editor = editor;
        // parse limits
        for (char limit : forbidden.toCharArray()) {
            switch (limit) {
                case 'e':
                    even = true;
                    break;
                case 'o':
                    odd = true;
                    break;
                case 'f':
                    first = true;
                    break;
                case 'l':
                    last = true;
                    break;
                case 'w':
                    all = true;
                    break;
                case 't':
                    oneTrack = true;
                    break;
                case 'c':
                    time = true;
                    break;
                default:
                    // no change
            }
        }
    }

    public String getKey() {
        return key;
    }

    public int getMaxWidth() {
        return maxWidth;
    }

    public int getMinWidth() {
        return minWidth;
    }

    public int getPrefWidth() {
        return prefWidth;
    }

    public Class<?> getClazz() {
        return clazz;
    }

    public boolean isRightAling() {
        return rightAling;
    }

    public TableCellEditor getEditor() {
        return editor;
    }

    public boolean isAllowedToEdit(int row, int max, TimeInterval interval) {
        if (all)
            return false;
        if (even && row % 2 == 0)
            return false;
        if (odd && row % 2 != 0)
            return false;
        if (first && row == 0)
            return false;
        if (last && row == max)
            return false;
        return !(oneTrack && interval.getOwner().getTracks().size() == 1);
    }

    public TableColumn createTableColumn() {
        TableColumn tableColumn = new TableColumn(this.ordinal(), this.getPrefWidth());
        tableColumn.setMinWidth(this.getMinWidth());
        tableColumn.setMaxWidth(this.getMaxWidth());
        if (this.isRightAling()) {
            DefaultTableCellRenderer cellRenderer = new DefaultTableCellRenderer();
            cellRenderer.setHorizontalAlignment(SwingConstants.RIGHT);
            tableColumn.setCellRenderer(cellRenderer);
            if (time) {
                tableColumn.setCellRenderer(new TimeCellRenderer(cellRenderer));
            }
        }
        if (this.getEditor() != null) {
            tableColumn.setCellEditor(this.getEditor());
        }
        String cName = ResourceLoader.getString(this.getKey());
        tableColumn.setHeaderValue(cName);
        return tableColumn;
    }

    public static TrainTableColumn getColumn(int index) {
        return values()[index];
    }

    public static int getIndex(TableColumnModel model, TrainTableColumn column) {
        Enumeration<TableColumn> e = model.getColumns();
        int i = 0;
        while (e.hasMoreElements()) {
            TableColumn tc = e.nextElement();
            if (tc.getModelIndex() == column.ordinal()) {
                return i;
            }
            i++;
        }
        return -1;
    }
}
